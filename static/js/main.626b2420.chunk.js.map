{"version":3,"sources":["Visualizer/Node/Node.jsx","Visualizer/StartFinish/MoveStartFinish.js","Visualizer/RowsCols/ChangeRowsCols.js","Visualizer/Animation/Animate.js","Messages/messageBoxUtils.js","Algorithms/dijkstra.js","Visualizer/Visualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","id","className","React","Component","handleMoveStart","state","isRunning","updateMessage","changingFinish","changingStart","document","getElementById","setState","handleMoveFinish","getNewGridWithStartChanged","grid","newGrid","slice","startRow","startCol","getNewGridWithFinishChanged","finishRow","finishCol","handleRowsChange","event","gridRows","target","value","prvStartRow","prvFinishRow","getInitialGrid","handleColsChange","gridCols","prvStartCol","prvFinishCol","animateDijkstra","visitedNodesInOrder","nodesInShortestPathOrder","console","log","timeoutArray","i","timeoutID","setTimeout","node","push","length","animateShortestPath","timeouts","resetAnimateDijkstra","concat","message","messageBox","innerText","dijkstra","startNode","finishNode","distance","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","Visaulizer","getNewGridWithWallToggled","newNode","mouseIsPressed","status","resetState","bind","createNode","visualizeDijkstra","clearTimeout","currentRow","currentNode","unshift","getNodesInShortestPathOrder","href","rel","onClick","type","name","min","max","onChange","map","rowIdx","key","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"+XAoCeA,G,6KA/BH,IAAD,EAUHC,KAAKC,MARPC,EAFK,EAELA,IACAC,EAHK,EAGLA,SACAC,EAJK,EAILA,QACAC,EALK,EAKLA,OACAC,EANK,EAMLA,YACAC,EAPK,EAOLA,aACAC,EARK,EAQLA,UACAC,EATK,EASLA,IAEIC,EAAiBP,EACnB,cACAC,EACA,aACAC,EACA,YACA,GAEJ,OACE,yBACEM,GAAE,eAAUF,EAAV,YAAiBP,GACnBU,UAAS,eAAUF,GACnBJ,YAAa,kBAAMA,EAAYG,EAAKP,IACpCK,aAAc,kBAAMA,EAAaE,EAAKP,IACtCM,UAAW,kBAAMA,W,GA1BNK,IAAMC,YCJlB,SAASC,IACVf,KAAKgB,MAAMC,UACbjB,KAAKkB,cACH,gEAIAlB,KAAKgB,MAAMG,eACbnB,KAAKkB,cACH,kEAIClB,KAAKgB,MAAMI,eAQdpB,KAAKkB,cAAc,+BACnBG,SAASC,eAAT,eAAuCV,UACrC,6BACFZ,KAAKuB,SAAS,CAAEH,eAAe,MAV/BpB,KAAKkB,cACH,wEAEFG,SAASC,eAAT,eAAuCV,UACrC,qCACFZ,KAAKuB,SAAS,CAAEH,eAAe,KAS5B,SAASI,IACVxB,KAAKgB,MAAMC,UACbjB,KAAKkB,cACH,iEAIAlB,KAAKgB,MAAMI,cACbpB,KAAKkB,cACH,iEAIClB,KAAKgB,MAAMG,gBAQdnB,KAAKkB,cAAc,+BACnBG,SAASC,eAAT,gBAAwCV,UACtC,8BACFZ,KAAKuB,SAAS,CAAEJ,gBAAgB,MAVhCnB,KAAKkB,cACH,yEAEFG,SAASC,eAAT,gBAAwCV,UACtC,sCACFZ,KAAKuB,SAAS,CAAEJ,gBAAgB,KAS7B,SAASM,EAA2BC,EAAMjB,EAAKP,GACpD,IAAMyB,EAAUD,EAAKE,QAUrB,OATAD,EAAQ3B,KAAKgB,MAAMa,UAAU7B,KAAKgB,MAAMc,UAAxC,2BACKH,EAAQ3B,KAAKgB,MAAMa,UAAU7B,KAAKgB,MAAMc,WAD7C,IAEE1B,SAAS,IAEXuB,EAAQlB,GAAKP,GAAb,2BACKyB,EAAQlB,GAAKP,IADlB,IAEEE,SAAS,IAEXJ,KAAKuB,SAAS,CAAEM,SAAUpB,EAAKqB,SAAU5B,IAClCyB,EAGF,SAASI,EAA4BL,EAAMjB,EAAKP,GACrD,IAAMyB,EAAUD,EAAKE,QAUrB,OATAD,EAAQ3B,KAAKgB,MAAMgB,WAAWhC,KAAKgB,MAAMiB,WAAzC,2BACKN,EAAQ3B,KAAKgB,MAAMgB,WAAWhC,KAAKgB,MAAMiB,YAD9C,IAEE9B,UAAU,IAEZwB,EAAQlB,GAAKP,GAAb,2BACKyB,EAAQlB,GAAKP,IADlB,IAEEC,UAAU,IAEZH,KAAKuB,SAAS,CAAES,UAAWvB,EAAKwB,UAAW/B,IACpCyB,ECjFF,SAASO,EAAiBC,GAAQ,IAAD,OACtC,IAAKnC,KAAKgB,MAAMC,UAAW,CACzB,IAAImB,EAAWD,EAAME,OAAOC,MACxBC,EAAcvC,KAAKgB,MAAMa,SACzBA,EAAWO,EAAWG,EAAc,EAAIH,EAAW,EAAIG,EACvDC,EAAexC,KAAKgB,MAAMgB,UAC1BA,EAAYI,EAAWI,EAAe,EAAIJ,EAAW,EAAII,EAE7DxC,KAAKuB,SACH,CAAEa,SAAUA,EAAUP,SAAUA,EAAUG,UAAWA,IACrD,WACE,EAAKT,SAAS,CAAEG,KAAM,EAAKe,mBAAoB,WAC7C,OAAO,SAMV,SAASC,EAAiBP,GAAQ,IAAD,OACtC,IAAKnC,KAAKgB,MAAMC,UAAW,CACzB,IAAI0B,EAAWR,EAAME,OAAOC,MACxBM,EAAc5C,KAAKgB,MAAMc,SACzBA,EAAWa,EAAWC,EAAc,EAAID,EAAW,EAAIC,EACvDC,EAAe7C,KAAKgB,MAAMiB,UAC1BA,EAAYU,EAAWE,EAAe,EAAIF,EAAW,EAAIE,EAE7D7C,KAAKuB,SACH,CAAEoB,SAAUA,EAAUb,SAAUA,EAAUG,UAAWA,IACrD,WACE,EAAKV,SAAS,CAAEG,KAAM,EAAKe,mBAAoB,WAC7C,OAAO,SC9BV,SAASK,EAAgBC,EAAqBC,GAA2B,IAAD,OAC7EC,QAAQC,IAAI,cAAelD,KAAKgB,MAAMC,WAGtC,IAFA,IAAMkC,EAAe,GAFwD,WAIpEC,GACP,IAAIC,EAAYC,YAAW,WACzB,IAAMC,EAAOR,EAAoBK,GACjC/B,SAASC,eAAT,eAAgCiC,EAAK9C,IAArC,YAA4C8C,EAAKrD,MAAOU,UACtD,sBACD,GAAKwC,GACRD,EAAaK,KAAKH,IANXD,EAAI,EAAGA,GAAKL,EAAoBU,OAAS,EAAGL,IAAM,EAAlDA,GAST,IAAIC,EAAYC,YAAW,WACzB,EAAKI,oBAAoBV,KACxB,GAAKD,EAAoBU,QAC5BN,EAAaK,KAAKH,GAClBrD,KAAKuB,SAAS,CAAEoC,SAAUR,IAAgB,WACxC,OAAO,KAKJ,SAASS,IACd,IAAK,IAAInD,EAAM,EAAGA,EAAMT,KAAKgB,MAAMoB,SAAU3B,IAC3C,IAAK,IAAIP,EAAM,EAAGA,EAAMF,KAAKgB,MAAM2B,SAAUzC,IACvCF,KAAKgB,MAAMU,KAAKjB,GAAKP,GAAKE,QAC5BiB,SAASC,eAAT,eAAgCb,EAAhC,YAAuCP,IAAOU,UAC5C,kBACOZ,KAAKgB,MAAMU,KAAKjB,GAAKP,GAAKC,SACnCkB,SAASC,eAAT,eAAgCb,EAAhC,YAAuCP,IAAOU,UAC5C,mBAEFS,SAASC,eAAT,eAAgCb,EAAhC,YAAuCP,IAAOU,UAAY,OAM3D,SAAS8C,EAAoBV,GAElC,IADA,IAAMG,EAAe,GADuC,WAEnDC,GACP,IAAIC,EAAYC,YAAW,WACzB,IAAMC,EAAOP,EAAyBI,GACtC/B,SAASC,eAAT,eAAgCiC,EAAK9C,IAArC,YAA4C8C,EAAKrD,MAAOU,UACtD,4BACD,GAAKwC,GACRD,EAAaK,KAAKH,IANXD,EAAI,EAAGA,EAAIJ,EAAyBS,OAAQL,IAAM,EAAlDA,GAQTpD,KAAKuB,SAAS,CAAEoC,SAAU3D,KAAKgB,MAAM2C,SAASE,OAAOV,KAAiB,WACpE,OAAO,KClDJ,SAASjC,IAA6B,IAAf4C,EAAc,uDAAJ,GAClCC,EAAa1C,SAASC,eAAe,cAErCwC,EACFC,EAAWC,UAAYF,EAInB9D,KAAKgB,MAAMC,YACb8C,EAAWC,UAAY,mCCLtB,SAASC,EAASvC,EAAMwC,EAAWC,GACxC,IAAMpB,EAAsB,GAC5BmB,EAAUE,SAAW,EAErB,IADA,IAAMC,EAsCR,SAAqB3C,GACnB,IADyB,EACnB4C,EAAQ,GADW,cAEP5C,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbjB,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAd8C,EAAa,QACtBe,EAAMd,KAAKD,IAFS,gCAFC,8BAOzB,OAAOe,EA7CgBC,CAAY7C,GAC1B2C,EAAeZ,QAAQ,CAC9Be,EAAoBH,GACpB,IAAMI,EAAcJ,EAAeK,QAEnC,IAAID,EAAYpE,OAAhB,CAGA,GAAIoE,EAAYL,WAAaO,IAAU,OAAO5B,EAG9C,GAFA0B,EAAYG,WAAY,EACxB7B,EAAoBS,KAAKiB,GACrBA,IAAgBN,EAAY,OAAOpB,EACvC8B,EAAyBJ,EAAa/C,KAI1C,SAAS8C,EAAoBH,GAC3BA,EAAeS,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMX,SAAWY,EAAMZ,YAG/D,SAASS,EAAyBtB,EAAM7B,GACtC,IAD4C,EACtCuD,EAOR,SAA+B1B,EAAM7B,GACnC,IAAMwD,EAAY,GACVhF,EAAaqD,EAAbrD,IAAKO,EAAQ8C,EAAR9C,IACTA,EAAM,GAAGyE,EAAU1B,KAAK9B,EAAKjB,EAAM,GAAGP,IACtCO,EAAMiB,EAAK+B,OAAS,GAAGyB,EAAU1B,KAAK9B,EAAKjB,EAAM,GAAGP,IACpDA,EAAM,GAAGgF,EAAU1B,KAAK9B,EAAKjB,GAAKP,EAAM,IACxCA,EAAMwB,EAAK,GAAG+B,OAAS,GAAGyB,EAAU1B,KAAK9B,EAAKjB,GAAKP,EAAM,IAC7D,OAAOgF,EAAUC,QAAO,SAACC,GAAD,OAAeA,EAASR,aAdrBS,CAAsB9B,EAAM7B,GADX,cAErBuD,GAFqB,IAE5C,2BAA2C,CAAC,IAAjCG,EAAgC,QACzCA,EAAShB,SAAWb,EAAKa,SAAW,EACpCgB,EAASE,aAAe/B,GAJkB,+B,UC8Q/BgC,E,kDArRb,WAAYtF,GAAQ,IAAD,8BACjB,cAAMA,IAqGRuF,0BAA4B,SAAC9D,EAAMjB,EAAKP,GACtC,IAAMyB,EAAUD,EAAKE,QACf2B,EAAO5B,EAAQlB,GAAKP,GACpBuF,EAAO,2BACRlC,GADQ,IAEXlD,QAASkD,EAAKlD,SAGhB,OADAsB,EAAQlB,GAAKP,GAAOuF,EACb9D,GA5GP,EAAKX,MAAQ,CACXU,KAAM,GACNU,SAAU,GACVO,SAAU,GACVd,SAAU,EACVC,SAAU,GACVE,UAAW,GACXC,UAAW,GACXyD,gBAAgB,EAChBzE,WAAW,EACX0C,SAAU,GACVvC,eAAe,EACfD,gBAAgB,EAChBwE,OAAQ,YAIV,EAAK5E,gBAAkBA,EACvB,EAAKS,iBAAmBA,EACxB,EAAKC,2BAA6BA,EAClC,EAAKM,4BAA8BA,EACnC,EAAKb,cAAgBA,EACrB,EAAKgB,iBAAmBA,EACxB,EAAKQ,iBAAmBA,EACxB,EAAKI,gBAAkBA,EACvB,EAAKc,qBAAuBA,EAC5B,EAAKF,oBAAsBA,EAG3B,EAAKkC,WAAa,EAAKA,WAAWC,KAAhB,gBAClB,EAAKpD,eAAiB,EAAKA,eAAeoD,KAApB,gBACtB,EAAKC,WAAa,EAAKA,WAAWD,KAAhB,gBAClB,EAAKE,kBAAoB,EAAKA,kBAAkBF,KAAvB,gBACzB,EAAK/C,gBAAkB,EAAKA,gBAAgB+C,KAArB,gBACvB,EAAKjC,qBAAuB,EAAKA,qBAAqBiC,KAA1B,gBAC5B,EAAKnD,iBAAmB,EAAKA,iBAAiBmD,KAAtB,gBACxB,EAAK3D,iBAAmB,EAAKA,iBAAiB2D,KAAtB,gBACxB,EAAK9E,gBAAkB,EAAKA,gBAAgB8E,KAArB,gBACvB,EAAKrE,iBAAmB,EAAKA,iBAAiBqE,KAAtB,gBACxB,EAAKpE,2BAA6B,EAAKA,2BAA2BoE,KAAhC,gBAGlC,EAAK9D,4BAA8B,EAAKA,4BAA4B8D,KAAjC,gBAGnC,EAAK3E,cAAgB,EAAKA,cAAc2E,KAAnB,gBA/CJ,E,yDAoDjB,GAAI7F,KAAKgB,MAAMC,UAAW,CAAC,IAAD,gBACFjB,KAAKgB,MAAM2C,UADT,IACxB,2BAA2C,CAAC,IAAnCN,EAAkC,QACzC2C,aAAa3C,IAFS,8BAIxBrD,KAAK4D,uBAEP5D,KAAKuB,SAAS,CACZG,KAAM1B,KAAKyC,iBACXiD,gBAAgB,EAChBzE,WAAW,EACXG,eAAe,EACfD,gBAAgB,IAElBnB,KAAKkB,cAAc,2B,0CAKnB,IAAMQ,EAAO1B,KAAKyC,iBAClBzC,KAAKuB,SAAS,CAAEG,SAChB1B,KAAKkB,cAAc,c,uCAMnB,IADA,IAAMQ,EAAO,GACJjB,EAAM,EAAGA,EAAMT,KAAKgB,MAAMoB,SAAU3B,IAAO,CAElD,IADA,IAAMwF,EAAa,GACV/F,EAAM,EAAGA,EAAMF,KAAKgB,MAAM2B,SAAUzC,IAC3C+F,EAAWzC,KAAKxD,KAAK8F,WAAW5F,EAAKO,IAEvCiB,EAAK8B,KAAKyC,GAEZ,OAAOvE,I,iCAIExB,EAAKO,GACd,MAAO,CACLP,MACAO,MACAL,QAASK,IAAQT,KAAKgB,MAAMa,UAAY3B,IAAQF,KAAKgB,MAAMc,SAC3D3B,SAAUM,IAAQT,KAAKgB,MAAMgB,WAAa9B,IAAQF,KAAKgB,MAAMiB,UAC7DmC,SAAUO,IACVC,WAAW,EACXvE,QAAQ,EACRiF,aAAc,Q,sCAeF7E,EAAKP,GAEnB,GADA+C,QAAQC,IAAIlD,KAAKgB,MAAMI,eACnBpB,KAAKgB,MAAMI,cAAe,CAC5B,IAAMO,EAAU3B,KAAKyB,2BACnBzB,KAAKgB,MAAMU,KACXjB,EACAP,GAEFF,KAAKuB,SAAS,CAAEG,KAAMC,SACjB,GAAI3B,KAAKgB,MAAMG,eAAgB,CACpC,IAAMQ,EAAU3B,KAAK+B,4BACnB/B,KAAKgB,MAAMU,KACXjB,EACAP,GAEFF,KAAKuB,SAAS,CAAEG,KAAMC,QACjB,CACL,IAAMA,EAAU3B,KAAKwF,0BAA0BxF,KAAKgB,MAAMU,KAAMjB,EAAKP,GACrEF,KAAKuB,SAAS,CAAEG,KAAMC,EAAS+D,gBAAgB,O,uCAIlCjF,EAAKP,GACpB,GAAKF,KAAKgB,MAAM0E,eAAhB,CACA,IAAM/D,EAAU3B,KAAKwF,0BAA0BxF,KAAKgB,MAAMU,KAAMjB,EAAKP,GACrEF,KAAKuB,SAAS,CAAEG,KAAMC,O,sCAItB3B,KAAKuB,SAAS,CAAEmE,gBAAgB,M,0CAI5B1F,KAAKgB,MAAMC,WAIfjB,KAAKuB,SAAS,CAAEN,WAAW,IAAQ,WACjCgC,QAAQC,IAAI,gBAAiBlD,KAAKgB,MAAMC,WACxCjB,KAAKkB,gBAGLG,SAASC,eAAT,eAAuCV,UACrC,6BACFZ,KAAKuB,SAAS,CAAEH,eAAe,IAG/BC,SAASC,eAAT,gBAAwCV,UACtC,8BACFZ,KAAKuB,SAAS,CAAEJ,gBAAgB,IAZa,IAerCO,EAAS1B,KAAKgB,MAAdU,KACFwC,EAAYxC,EAAK1B,KAAKgB,MAAMa,UAAU7B,KAAKgB,MAAMc,UACjDqC,EAAazC,EAAK1B,KAAKgB,MAAMgB,WAAWhC,KAAKgB,MAAMiB,WACnDc,EAAsBkB,EAASvC,EAAMwC,EAAWC,GAChDnB,EDpIL,SAAqCmB,GAG1C,IAFA,IAAMnB,EAA2B,GAC7BkD,EAAc/B,EACK,OAAhB+B,GACLlD,EAAyBmD,QAAQD,GACjCA,EAAcA,EAAYZ,aAE5B,OAAOtC,EC6H8BoD,CAA4BjC,GAC7DnE,KAAK8C,gBAAgBC,EAAqBC,Q,+BAIpC,IAAD,SAC0BhD,KAAKgB,MAA9BU,EADD,EACCA,KAAMgE,EADP,EACOA,eAEd,OACE,oCACE,0BACEW,KAAK,0DACLC,IAAI,eAEN,yBAAK1F,UAAU,YAEb,4BACE2F,QAASvG,KAAK+F,kBACdnF,UAAU,8BAEV,iEAIF,4BAAQ2F,QAASvG,KAAK4F,WAAYhF,UAAU,0BAC1C,kDAEF,yBAAKA,UAAU,cACb,uBAAGD,GAAG,gBAKR,4BACE4F,QAASvG,KAAKe,gBACdH,UAAU,6BACVD,GAAG,eAEH,8CAIF,4BACE4F,QAASvG,KAAKwB,iBACdZ,UAAU,8BACVD,GAAG,gBAEH,gDAGJ,6BAEE,2BAAOA,GAAG,WAAW,SAAWX,KAAKgB,MAAMoB,UAC3C,2BACEoE,KAAK,QACL7F,GAAG,MACHC,UAAU,YACV6F,KAAK,MACLC,IAAI,KACJC,IAAI,KACJrE,MAAOtC,KAAKgB,MAAMoB,SAClBwE,SAAU5G,KAAKkC,mBAGjB,2BAAOvB,GAAG,WAAW,YAAcX,KAAKgB,MAAM2B,UAC9C,2BACE6D,KAAK,QACL7F,GAAG,MACHC,UAAU,YACV6F,KAAK,MACLC,IAAI,KACJC,IAAI,KACJrE,MAAOtC,KAAKgB,MAAM2B,SAClBiE,SAAU5G,KAAK0C,oBAGnB,yBAAK9B,UAAU,QACZc,EAAKmF,KAAI,SAACpG,EAAKqG,GACd,OACE,yBAAKC,IAAKD,GACPrG,EAAIoG,KAAI,SAACtD,EAAMyD,GAAa,IACnBvG,EAAwC8C,EAAxC9C,IAAKP,EAAmCqD,EAAnCrD,IAAKC,EAA8BoD,EAA9BpD,SAAUC,EAAoBmD,EAApBnD,QAASC,EAAWkD,EAAXlD,OACrC,OACE,kBAAC,EAAD,CACE0G,IAAKC,EACLvG,IAAKA,EACLP,IAAKA,EACLC,SAAUA,EACVC,QAASA,EACTC,OAAQA,EACRqF,eAAgBA,EAChBpF,YAAa,SAACG,EAAKP,GAAN,OAAc,EAAK+G,gBAAgBxG,EAAKP,IACrDK,aAAc,SAACE,EAAKP,GAAN,OACZ,EAAKgH,iBAAiBzG,EAAKP,IAE7BM,UAAW,kBAAM,EAAK2G,gC,GAzQnBtG,IAAMC,WCPhBsG,MARf,WACE,OACE,yBAAKxG,UAAU,OACb,kBAAC,EAAD,QCKcyG,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFvG,SAASC,eAAe,SDyHpB,kBAAmBuG,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLnF,QAAQmF,MAAMA,EAAMtE,c","file":"static/js/main.626b2420.chunk.js","sourcesContent":["import React from \"react\";\n\nimport \"./Node.css\";\n\nclass Node extends React.Component {\n  render() {\n    const {\n      col,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n      row,\n    } = this.props;\n    const extraClassName = isFinish\n      ? \"node-finish\"\n      : isStart\n      ? \"node-start\"\n      : isWall\n      ? \"node-wall\"\n      : \"\";\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}\n      ></div>\n    );\n  }\n}\n\nexport default Node;\n","export function handleMoveStart() {\n  if (this.state.isRunning) {\n    this.updateMessage(\n      \"Cannot change while running! Reset to change Start position.\"\n    );\n    return;\n  }\n  if (this.state.changingFinish) {\n    this.updateMessage(\n      \"Please toggle 'Move Finish' button before choosing this option\"\n    );\n    return;\n  }\n  if (!this.state.changingStart) {\n    this.updateMessage(\n      \"Click a new box to move the Start position. Toggle button when done.\"\n    );\n    document.getElementById(`startButton`).className =\n      \"moveStartButton topButtons pressed\";\n    this.setState({ changingStart: true });\n  } else {\n    this.updateMessage(\"Changes saved successfully.\");\n    document.getElementById(`startButton`).className =\n      \"moveStartButton topButtons\";\n    this.setState({ changingStart: false });\n  }\n}\n\nexport function handleMoveFinish() {\n  if (this.state.isRunning) {\n    this.updateMessage(\n      \"Cannot change while running! Reset to change Finish position.\"\n    );\n    return;\n  }\n  if (this.state.changingStart) {\n    this.updateMessage(\n      \"Please toggle 'Move Start' button before choosing this option\"\n    );\n    return;\n  }\n  if (!this.state.changingFinish) {\n    this.updateMessage(\n      \"Click a new box to move the Finish position. Toggle button when done.\"\n    );\n    document.getElementById(`finishButton`).className =\n      \"moveFinishButton topButtons pressed\";\n    this.setState({ changingFinish: true });\n  } else {\n    this.updateMessage(\"Changes saved successfully.\");\n    document.getElementById(`finishButton`).className =\n      \"moveFinishButton topButtons\";\n    this.setState({ changingFinish: false });\n  }\n}\n\nexport function getNewGridWithStartChanged(grid, row, col) {\n  const newGrid = grid.slice();\n  newGrid[this.state.startRow][this.state.startCol] = {\n    ...newGrid[this.state.startRow][this.state.startCol],\n    isStart: false,\n  };\n  newGrid[row][col] = {\n    ...newGrid[row][col],\n    isStart: true,\n  };\n  this.setState({ startRow: row, startCol: col });\n  return newGrid;\n}\n\nexport function getNewGridWithFinishChanged(grid, row, col) {\n  const newGrid = grid.slice();\n  newGrid[this.state.finishRow][this.state.finishCol] = {\n    ...newGrid[this.state.finishRow][this.state.finishCol],\n    isFinish: false,\n  };\n  newGrid[row][col] = {\n    ...newGrid[row][col],\n    isFinish: true,\n  };\n  this.setState({ finishRow: row, finishCol: col });\n  return newGrid;\n}\n","export function handleRowsChange(event) {\n  if (!this.state.isRunning) {\n    let gridRows = event.target.value;\n    let prvStartRow = this.state.startRow;\n    let startRow = gridRows < prvStartRow + 1 ? gridRows - 1 : prvStartRow;\n    let prvFinishRow = this.state.finishRow;\n    let finishRow = gridRows < prvFinishRow + 1 ? gridRows - 1 : prvFinishRow;\n    // Quick hack to set state synchoronously.\n    this.setState(\n      { gridRows: gridRows, startRow: startRow, finishRow: finishRow },\n      () => {\n        this.setState({ grid: this.getInitialGrid() }, () => {\n          return 0;\n        });\n      }\n    );\n  }\n}\nexport function handleColsChange(event) {\n  if (!this.state.isRunning) {\n    let gridCols = event.target.value;\n    let prvStartCol = this.state.startCol;\n    let startCol = gridCols < prvStartCol + 1 ? gridCols - 1 : prvStartCol;\n    let prvFinishCol = this.state.finishCol;\n    let finishCol = gridCols < prvFinishCol + 1 ? gridCols - 1 : prvFinishCol;\n    // Quick hack to set state synchoronously.\n    this.setState(\n      { gridCols: gridCols, startCol: startCol, finishCol: finishCol },\n      () => {\n        this.setState({ grid: this.getInitialGrid() }, () => {\n          return 0;\n        });\n      }\n    );\n  }\n}\n","export function animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n  console.log(\"In Animate:\", this.state.isRunning);\n  const timeoutArray = [];\n  // Iterate through up until one before last element.\n  for (let i = 0; i <= visitedNodesInOrder.length - 1; i++) {\n    let timeoutID = setTimeout(() => {\n      const node = visitedNodesInOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-visited\";\n    }, 10 * i);\n    timeoutArray.push(timeoutID);\n  }\n  // The last element is finish node.\n  let timeoutID = setTimeout(() => {\n    this.animateShortestPath(nodesInShortestPathOrder);\n  }, 10 * visitedNodesInOrder.length);\n  timeoutArray.push(timeoutID);\n  this.setState({ timeouts: timeoutArray }, () => {\n    return 0;\n  });\n  return;\n}\n\nexport function resetAnimateDijkstra() {\n  for (let row = 0; row < this.state.gridRows; row++) {\n    for (let col = 0; col < this.state.gridCols; col++) {\n      if (this.state.grid[row][col].isStart) {\n        document.getElementById(`node-${row}-${col}`).className =\n          \"node node-start\";\n      } else if (this.state.grid[row][col].isFinish) {\n        document.getElementById(`node-${row}-${col}`).className =\n          \"node node-finish\";\n      } else {\n        document.getElementById(`node-${row}-${col}`).className = \"node\";\n      }\n    }\n  }\n}\n\nexport function animateShortestPath(nodesInShortestPathOrder) {\n  const timeoutArray = [];\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    let timeoutID = setTimeout(() => {\n      const node = nodesInShortestPathOrder[i];\n      document.getElementById(`node-${node.row}-${node.col}`).className =\n        \"node node-shortest-path\";\n    }, 50 * i);\n    timeoutArray.push(timeoutID);\n  }\n  this.setState({ timeouts: this.state.timeouts.concat(timeoutArray) }, () => {\n    return 0;\n  });\n}\n","export function updateMessage(message = \"\") {\n  let messageBox = document.getElementById(\"messageBox\");\n  //  Update displayed message using the passed argument.\n  if (message) {\n    messageBox.innerText = message;\n  }\n  //  If no message is passed change based on state values\n  else {\n    if (this.state.isRunning) {\n      messageBox.innerText = \"Running Dijkstra's Algorithm...\";\n    }\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React from \"react\";\nimport Node from \"./Node/Node\";\nimport {\n  handleMoveStart,\n  handleMoveFinish,\n  getNewGridWithStartChanged,\n  getNewGridWithFinishChanged,\n} from \"./StartFinish/MoveStartFinish\";\nimport { handleRowsChange, handleColsChange } from \"./RowsCols/ChangeRowsCols\";\nimport {\n  animateDijkstra,\n  resetAnimateDijkstra,\n  animateShortestPath,\n} from \"./Animation/Animate\";\nimport { updateMessage } from \"../Messages/messageBoxUtils\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\n\nimport \"./Visualizer.css\";\n\nclass Visaulizer extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      gridRows: 18,\n      gridCols: 50,\n      startRow: 5,\n      startCol: 10,\n      finishRow: 15,\n      finishCol: 40,\n      mouseIsPressed: false,\n      isRunning: false,\n      timeouts: [],\n      changingStart: false,\n      changingFinish: false,\n      status: \"Welcome!\",\n    };\n\n    // Add Functions exported to the class.\n    this.handleMoveStart = handleMoveStart;\n    this.handleMoveFinish = handleMoveFinish;\n    this.getNewGridWithStartChanged = getNewGridWithStartChanged;\n    this.getNewGridWithFinishChanged = getNewGridWithFinishChanged;\n    this.updateMessage = updateMessage;\n    this.handleRowsChange = handleRowsChange;\n    this.handleColsChange = handleColsChange;\n    this.animateDijkstra = animateDijkstra;\n    this.resetAnimateDijkstra = resetAnimateDijkstra;\n    this.animateShortestPath = animateShortestPath;\n\n    // Bind the function to get access to this.state\n    this.resetState = this.resetState.bind(this);\n    this.getInitialGrid = this.getInitialGrid.bind(this);\n    this.createNode = this.createNode.bind(this);\n    this.visualizeDijkstra = this.visualizeDijkstra.bind(this);\n    this.animateDijkstra = this.animateDijkstra.bind(this);\n    this.resetAnimateDijkstra = this.resetAnimateDijkstra.bind(this);\n    this.handleColsChange = this.handleColsChange.bind(this);\n    this.handleRowsChange = this.handleRowsChange.bind(this);\n    this.handleMoveStart = this.handleMoveStart.bind(this);\n    this.handleMoveFinish = this.handleMoveFinish.bind(this);\n    this.getNewGridWithStartChanged = this.getNewGridWithStartChanged.bind(\n      this\n    );\n    this.getNewGridWithFinishChanged = this.getNewGridWithFinishChanged.bind(\n      this\n    );\n    this.updateMessage = this.updateMessage.bind(this);\n  }\n\n  // Function to reset/clear board\n  resetState() {\n    if (this.state.isRunning) {\n      for (let timeoutID of this.state.timeouts) {\n        clearTimeout(timeoutID);\n      }\n      this.resetAnimateDijkstra();\n    }\n    this.setState({\n      grid: this.getInitialGrid(),\n      mouseIsPressed: false,\n      isRunning: false,\n      changingStart: false,\n      changingFinish: false,\n    });\n    this.updateMessage(\"Board has been reset.\");\n  }\n\n  // after all the elements of the page is rendered correctly, this method is called.\n  componentDidMount() {\n    const grid = this.getInitialGrid();\n    this.setState({ grid });\n    this.updateMessage(\"Welcome!\");\n  }\n\n  // Get grid when the page reloads/when reset.\n  getInitialGrid() {\n    const grid = [];\n    for (let row = 0; row < this.state.gridRows; row++) {\n      const currentRow = [];\n      for (let col = 0; col < this.state.gridCols; col++) {\n        currentRow.push(this.createNode(col, row));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }\n\n  // Create node as an Object with various useful properties.\n  createNode(col, row) {\n    return {\n      col,\n      row,\n      isStart: row === this.state.startRow && col === this.state.startCol,\n      isFinish: row === this.state.finishRow && col === this.state.finishCol,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n    };\n  }\n\n  getNewGridWithWallToggled = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const node = newGrid[row][col];\n    const newNode = {\n      ...node,\n      isWall: !node.isWall,\n    };\n    newGrid[row][col] = newNode;\n    return newGrid;\n  };\n\n  handleMouseDown(row, col) {\n    console.log(this.state.changingStart);\n    if (this.state.changingStart) {\n      const newGrid = this.getNewGridWithStartChanged(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else if (this.state.changingFinish) {\n      const newGrid = this.getNewGridWithFinishChanged(\n        this.state.grid,\n        row,\n        col\n      );\n      this.setState({ grid: newGrid });\n    } else {\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    if (!this.state.mouseIsPressed) return;\n    const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\n    this.setState({ grid: newGrid });\n  }\n\n  handleMouseUp() {\n    this.setState({ mouseIsPressed: false });\n  }\n\n  visualizeDijkstra() {\n    if (this.state.isRunning) {\n      return;\n    }\n    // this.state.isRunning = true;\n    this.setState({ isRunning: true }, function () {\n      console.log(\"In Visualize:\", this.state.isRunning);\n      this.updateMessage();\n\n      // Reset Move Start Button\n      document.getElementById(`startButton`).className =\n        \"moveStartButton topButtons\";\n      this.setState({ changingStart: false });\n\n      // Reset Move Finish Button\n      document.getElementById(`finishButton`).className =\n        \"moveFinishButton topButtons\";\n      this.setState({ changingFinish: false });\n\n      // Algorithm in motion!\n      const { grid } = this.state;\n      const startNode = grid[this.state.startRow][this.state.startCol];\n      const finishNode = grid[this.state.finishRow][this.state.finishCol];\n      const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n      const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n      this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n    });\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        <link\n          href=\"https://fonts.googleapis.com/icon?family=Material+Icons\"\n          rel=\"stylesheet\"\n        ></link>\n        <div className=\"firstBar\">\n          {/* Button to Reset State */}\n          <button\n            onClick={this.visualizeDijkstra}\n            className=\"algorithmButton topButtons\"\n          >\n            <span>Visualize Dijkstra's Algorithm</span>\n          </button>\n\n          {/* Button to Reset State */}\n          <button onClick={this.resetState} className=\"resetButton topButtons\">\n            <span>Press to Reset!</span>\n          </button>\n          <div className=\"messageBox\">\n            <p id=\"messageBox\"></p>\n          </div>\n          {/* <p id=\"messageBox\"></p> */}\n\n          {/* Button to Move Start node across grid */}\n          <button\n            onClick={this.handleMoveStart}\n            className=\"moveStartButton topButtons\"\n            id=\"startButton\"\n          >\n            <span>Move Start!</span>\n          </button>\n\n          {/* Button to Move Finish node across grid */}\n          <button\n            onClick={this.handleMoveFinish}\n            className=\"moveFinishButton topButtons\"\n            id=\"finishButton\"\n          >\n            <span>Move Finish!</span>\n          </button>\n        </div>\n        <div>\n          {/* Slider to change Rows */}\n          <label id=\"numRows\">{\"Rows: \" + this.state.gridRows}</label>\n          <input\n            type=\"range\"\n            id=\"vol\"\n            className=\"rowSlider\"\n            name=\"vol\"\n            min=\"10\"\n            max=\"20\"\n            value={this.state.gridRows}\n            onChange={this.handleRowsChange}\n          ></input>\n          {/* Slider to change Columns */}\n          <label id=\"numCols\">{\"Columns: \" + this.state.gridCols}</label>\n          <input\n            type=\"range\"\n            id=\"vol\"\n            className=\"colSlider\"\n            name=\"vol\"\n            min=\"10\"\n            max=\"65\"\n            value={this.state.gridCols}\n            onChange={this.handleColsChange}\n          ></input>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      row={row}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nexport default Visaulizer;\n","import React from \"react\";\nimport \"./App.css\";\nimport Visaulizer from \"./Visualizer/Visualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Visaulizer></Visaulizer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}